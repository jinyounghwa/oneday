2강에서는 플로우에 대해 자세하게 알아보는 시간이었습니다.  
강의의 목적은 실무 중심이 목표라 라이브러리나 아키텍처보다 실제로는 for나 if를 제대로 쓰는 플로우를 컨트롤이 중요합니다.  

자바스크립트는 label, break, continue를 제공하고 있습니다. 기본적인 플로우를 제공합니다.
기본 플로우는 왼쪽에서 오른쪽입니다. 예외 중 한가지는 goto(점프)입니다.
자바스크립트는 label로 제공합니다. 반드시 언더바(_) 달라 ($)를 붙여 만듭니다.
continue,break는 label을 탈출하는데 쓰입니다.  

label은 같은 이름으로 두개 만들 수 없습니다. 블록스코프도 불가능합니다. 
그렇다면 함수 스코프는 어떨까요? 에러가 나지 않습니다. 레이블은 변수처럼 함수 스코프를 사용합니다.  
label이 가르키는것은 label range라고 합니다. break에 식별자가 없으면 자동 label만 발생되어 있는 상황에서만 발생합니다.
label set(영역)은 명시적으로 식별자를 구분해 놓지 않으면 에러가 납니다.

현재 언어들의 점프 상황은 위에서 아래로 실행되는 순서를 가집니다. label 점프만이 언어서는 유일하게 서브루틴이 제일 밑으로 보내집니다.
label 블럭에서는 continue를 쓸 수 없다. 이토레이션 셋에서만 가능합니다.
기본적인 흐름제어는 label set과 break문을 이용 할 수 있습니다. 실행될 수 있는 부분과 그 이외로 나누어서 return처럼 쓸 수 있습니다.

break label, continue label을 undefined label이라고 합니다.엔진이 문을 번역해서 객체화 하였을 때 Record라는걸로 바뀌어 실행하면서 처리합니다.
흐름제어에 관여하는 레코드(분기를 일으키는 레코드)를 Completion Record라고 부릅니다.(mdn문서 링크 유실됨)

앞서 작성한 것처럼 label은 function scope로 되어 있습니다. shadowing도 일어납니다.(mdn에서는 shadowing을 '가려짐' 이라는 한글로 표기하였습니다.) 변수에는 두가지의 속성이 있습니다. 변수는 영원히 존재하지 않고 특정시점에 탄생 후 사라지며 (lifecycle을 가짐) 그리고 접근제어를 가집니다. (scope : 접근권한) 자바스크립트의 scope는 변수의 lifecycle을 가리킵니다. (다른 언어와 설명이 다릅니다.)
변수는 생존기간과 접근권한을 가지고 있습니다. 변수는 보통 함수의 인자, 함수안에서 선언되는 지역변수, ES6의 블록안에서 만들어진 블록변수와 클래스의 
인스턴스인 멤버변수 (객체가 사라질 때까지 지속적으로 보존됨)가 있습니다.  

그래서 자유변수와 클로저라는 개념이 생깁니다. 자유번수란 함수나 인스턴스등의 자기를 기준으로 자기가 알 수 없는 권한을 가진 변수를 이야기합니다.
함수를 예로 들을 때 지역변수와 인자가 아니면 자유변수입니다. 클래스 매서드의 경우에도 this로 시작되는 멤버변수, 함수인자, 지역변수를 제외한 모두가 
자유변수입니다. 자유변수는 다 쓸수 있는것은 아닙니다. 자유변수들이 쓸수 있는 공간을 우리는 클로저라고 합니다. 함수에서 감싸고 있는 함수가 특정 자유변수에 대한 클로저라고 할 수 있습니다.

일반적인 언어들은 자유변수와 자유변수가 아닌 변수의 이름이 같으면 일반적인 언어들은 자기 변수를 우선시하는 경향이 있습니다. 자유변수의 우선순위는 낮습니다. 이름이 같을 때 바깥쪽의 자유 변수가 안 보이는 효과를 가지는데 이것을 shadowing이라고 합니다. 지금 언어들은 함수 바깥에 있는 레이블을 
예전과 다르게 점프 할 수 없기 때문이기도 합니다. 레이블 기반의 점프는 매우 안전한 편인데 언어를 파싱하는 레코드에서 syntax error가 나기 때문입니다. 현대의 언어들은 함수스코프가 나와있는 레이블을 바깥으로 나가지 못하게 합니다. 이것을 label scope라고 합니다.레이블에 블록이 없으면 다음에 나와있는 단문을 소유하게 됩니다.label set 하나는 문 하나를 뜻합니다.

그래서 label에 block를 두면 block range전체가 그 label의 target이 됩니다. 또한 goto last는 항상 위로가는데 다른 이동과 가장 다른 차이를 가집니다. iteration set과 label set은 모두 break와 contiune에 대한 이야기라고 할 수 있습니다. iteration set은 익명이라는 부분이 다른 점이 있습니다. (contiune 익명은 흉내 낼 수 없음 : goto가 흉내낼 수 없는 부분)

Switch문을 보면 중괄호, 콜론, 식으로 되어있습니다. 콜론도 label이라고 할 수 있습니다. Switch문에서 나오는 중괄호는 중문이 아닙니다. 중괄호는 Switch label block이라고 합니다. 특수 label로 문법적인 형식으로 반드시 붙여야 합니다. case를 띄고 식이 들어 올 수 있습니다. 항상 위에서 아래로 떨어지는 fall through 현상을 가집니다. Switch문에 있는 break문은 위의 iteration set, label set 과는 다르게 익명을 만들어 주고 있습니다. 레이블 효과만 있기 때문입니다. (점프를 하려고 하면 아래가 실행되지 바로 바깥으로 빠져 나갈 수 있기 때문입니다.) 그래서 switch label이 만들어 집니다.
식을 매번 평가할 수 있기 때문에 만약에 값으로 확정지을 수 없고 조건으로 확정지을려고 하는 case문을 만들려고 하면 한정적 조건을 쓰고 case로 식을 전개하면 됩니다. 반대로도 사용 할 수 있습니다. 일반적으로 순서 관계가 제약으로 생기기 때문에 독립적인 조건을 기술 할 때는 유리하지만, 여러 경우가 관련되어 있는 조건들을 사용할 때 로직이 복잡해질 수 있습니다.

 지금까지 contiune와 break에 대해 이야기 했습니다. label에 단문이 오는 경우 블럭이 없으므로 contiune와 break를 쓸 방법이 없습니다. 이러한 속성을 이용하면 주석대신 label을 사용 할 수 있습니다. 지금까지 흐름제어의 기본인 label을 배웠습니다. 
 현대 언어의 흐름제어는 이것 뿐만 아닌 조건문(if)와 반복문(for)을 사용합니다. 이제는 조건문 (conditional statement)에 대해 알아보도록 하겠습니다.

if문 다음에는 식이 들어와서 값을 판단하도록 하여 옵셔널 하게 합니다. 그에 비하여 else if 는 필수적입니다. 그러기에 if 다음에는 중문이 들어오고 else if는 사실상 if-else의 반복인 셈입니다. 경우에 따라 else switch나 else for도 들어 갈 수 있습니다. if 의 else가 후방결합이라는 특성이 있어서 이것을 이해하지 않으면 어렵습니다. 연산자 우선순위와 같이 반드시 else if를 사용하지 말고 반드시 else를 사용하여 무조건 중괄호를 사용하는 습관을 들여야 합니다. 병행 조건일 때는 (평가할 식들이 동등할 때는) switch를 써야 합니다. 서브집합의 관계에서만 else if를 사용합니다. 

else안에 if가 들어있으면 반드시 else가 들어가 있어야 로직을 이해할 수 있습니다. switch를 쓰면 반드시 default가 있어 병행조건에서 생기는 예외상황을 대비해야 합니다. 

이제 반복문인 for에 대해 알아봅시다. 기본적인 for문은 for (ex;ex;ex) ex에 들어가는것은 식입니다. 그런데 식의 자리에는 선언문 (var i = 0) 과 같은 선언문, 공문도 들어 갈 수 있습니다. ('',flase,0,undefined,null,NaN 와 같은 falsy 값이 가운데 식 자리에 들어 갈 수 없습니다. 반드시 truthy만 들어갑니다.) for의 가운데 식 자리에 없는경우 truthy로 돌게됩니다. 그렇기 때문에 무한루프가 생기는 경우가 발생하게 됩니다.

그에비해 while문은 식이 truthy인 경우 계속 반복됩니다. do while 반드시 한번 실행 될 경우 사용합니다. truthy에 평가하게 하고 중괄호 안에 빠져나오는 상태를 넣어 무한루프를 방지합니다. 이 경우를 이용하여 조건식에 대한 상태가 바디부분에 등장하는가를 잘 보는게 중요합니다.















