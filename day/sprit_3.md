코드 스피리츠 3회차 후기

이번 시간에는 기본적인 제어흐름에서의 반복구문에 대한 내용입니다.

일반적인 제어 흐름에 대한 이야기이며 다음에는 코루틴을 합니다.  
자바스크립트에서 이제부터는 인터페이스에 대한 이야기를 해봅시다. 인터페이스는 고유명사이니다. (ES6이후)
1. 인터페이스는 사양에 맞는 값과 연결된 속성키의 세트입니다.
2. 어던 Object라도 인터페이스의 정의를 충족 시키실 수 있습니다.
3. 하나의 Object는 여러개의 인터페이스를 충족 시킬 수 있습니다.

마치 JAVA에서 클래스가 여러 오브젝트를 생성하는 것과 비슷합니다. 
예로  TEST라는 인터페이스를 생각해봅시다. 이것은
1. test라는 키를 가지고
2. 값으로 문자열인자를 1개 받아 불린 결과를 반환하는 함수가 옵니다.
test인터페이스를 제대로 구분하려면 키와 함수를 가지고 있습니다. 

인터페이스 개념은 duck typing에서 왔습니다. 클래스는 단지 구현만 하고 있을 뿐이지 해당 메소드를 가지고 있는게 보장되지는 않습니다. 인스턴스 일 뿐이라 컴파일 에러가 나지 않습니다. 객체가 느슨하게 인터페이스를 구현했다면 그게 뭐든 상관하지 않겠다. (조건이 맞다면 해당 인터페이스의 사용가능할 객체로 인식하겠다 라는 말이죠.. 타입체크가 안 되기 때문에 사용합니다.)
덕타이핑이 어려운 이유는 이것을 우리 머리속에서 구현하기 어렵기 때문입니다. 실제 사용하려면 상당히 어렵습니다. 

그러면 인터페이스가 무엇인지 알았으니 스펙에서 미리 규정하고 있는 인터페이스를 알아보겠습니다.
이중에 반복문과 관련된 것이 두가지 있습니다. 그중 하나는 ITERATOR INTERFACE입니다. 이것은 무엇을 요구하냐면 다음과 같습니다.
1. next라는 키를 가지고 
2. 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 프로토콜입니다.
3. IteratorResultObject(이것도 인터페이스 입니다.) 는 value와 done라는 키를 가지고 있습니다.
4. 이중 done은 계속 반환할 수 있을지 없을지에 따라 불린값을 반환합니다.

인터페이스가 인터페이스를 부르는 경우가 많으니 예제들을 검색해서 찾아보도록 합시다. 
done는 next를 부를지 말지 판단할 때 사용하고 value는 그때그때 값을 받아오기 위함이라고 일단 머리에 넣어봅시다.

그럼 이것을 어떨 때 사용할 수 있을까요? 의도적으로 내부에 변수를 숨겨 반복을 구현하여 데이터 길이만큼 순환할 경우 등으로 확인 할 수 있습니다.

이제는 ITERABLE INTERFACE(위의것과 헷갈리지만 구분해서 반드시 외워야 합니다.)
1. Symbol.iterator라는 키를 가지고
2. 값으로 인자를 받지 않고 IteratorObject를 반환해야 합니다.

Symbol은 ES6에서 생긴 primitive type(메모리에 복사가 일어나는 형식의 타입:참조가 아니라 복사가 일어나는 모든 심볼은 유니크 값입니다.)
사용할 때 대괄호 [Symbol.iterator] 라고 씁니다. (new를 사용할 수 없습니다.) 심볼은 원래 내장하고 있는 심볼(well-known symbols)가 있습니다.
영문이지만 아래 링크에 소개가 있으니 시간나실 때 읽어봐 주세요(저도 읽어보겠습니다.)
http://2ality.com/2015/09/well-known-symbols-es6.html
또한 강의에서 말씀하신 심볼이 어떤 문자열 인터페이스로 대체되는지 대한 표등에 대한 링크는 아래의 글을 한번 읽어보시고 그 글의 링크를 클릭하셔서 확인해 보시면 됩니다.
http://www.bsidesoft.com/2306

well-known symbols는 문자로 대체가 가능합니다. 키가 변수의 명명규칙에 일치하지 않아도 대괄호 규칙을 하는것을 권합니다. 비슷한 영어발음이어서 헷갈리는것 중에 하나가 ITERABLE의 키가 iterator라는 부분입니다. ES6에서는 키가 오고 괄호가 오면 [Symbol.iterator] () key:function이 온 것과 같은 의미를 가집니다.(메소드 문법이라 합니다.)


ITERABLE의 의미는 iterator로 한번 반복시키고 나면, 수명이 다해서 없어지는데 원본을 두고 계속해서 반복 하는 방법을 사용하기 위함입니다.(class를 사용합니다.) 이것이 바로 ITERABLE 인터페이스 입니다.

이제 인터페이스에 대한 개념을 배웠으니 이제는 LOOP에 대하여 배워봅시다.
ES6는 스팩과 엔진으 모두 새롭게 구성되어 있기 때문에 기존의 방식은 전혀 통용되지 않습니다. 이 점을 유의하여 새로운 마음으로 배워보도록 하겠습니다.

ES6는 어떤 방식으로 플로우를 컨트롤 할까요? while문의 구조로 한번 살펴보도록 하겠습니다. 이것을 Iterator interface로 보면 구조는 거의 비슷하다는 것을 느낄 수 있습니다. 다만 판단을 내부에 맡기고 처리할 것이 값이라면 또한 출력이 가능합니다. 구조를 거의 흉내 낸다고 할 수 있습니다. JAVA도 마찬가지 입니다. 

물론 차이점이 있습니다. 값과 문의 차이입니다. 문으로 루프를 돌리면 재현이 불가능하고 원할 때 실행하기도 어렵습니다. 휘발성이죠.. 값으로 바꾸지 않으면.. 컴퓨터 성능에 대한 차이와 같이 문은 그런 동작구조이지만 Iterator와 같이 값으로 실행하면 우리가 제어할 수 있습니다. (지연처리와 흐름제어라고 합니다. 해당포스팅은 아래 링크 입니다.)
http://www.bsidesoft.com/?p=2862

지연처리라는 말은 실행 도중에 실행을 점프시키고 처리하는 것을 말합니다. 또한 연산자를 지연처리도 있고 호출 지연도 있습니다. 함수를 실행했을 때 결과는 값이기에 원하는 때에 실행할 수 있는 처리가 가능한 것입니다.

다시 돌아와서 문(while의 경우) 휘발성이며 통제가 되지 않습니다만, 그에 비애 Iterator interface는 next()호출 할 때까지 다음번 루프가 실행되지 않습니다. 호출을 원할 때 할 수 있습니다. 값으로 바꾸고 함수의 호출 지연을 사용하기 때문입니다. 대신에 귀찮은게 있다면 문은 실행을 엔진이 하지만
Iterator interface(공급기)는 실행기를 반드시 만들어야 합니다.
정리하자면 다음과 같습니다.
1. 반복자체는 하지 않지만
2. 외부에서 반복을 하려고 할 때
3. 반복에 필요한 존건과 실행을 
4. 미리 준비해 둔 객체에서 
-반복행위(진짜로 next를 호출)와 반복(상태준비)을 위한 준비를 분리합니다.-
1. 미리 반복에 대한 준비를 해두고(이것조차 객체에 위임합니다.)
2. 필요할 대 필요한 만큼 반복
3. 반복을 재현할 수 있음(문과는 달리 통제도 가능함)

기본적으로 서술적 표현이었던 문을 대상화 시키서 쉬워지게 만들어 한다고 생각하여 쉽게 사용할 수 있겠지.. 라고 대상화 하여 만든것입니다... 
미리준비해 둔 객체라고 합니다. 객체의 중요한 특성은 캡슐화 입니다. 결과를 구현해 내는 과정에 대한 부분이 노출되지 않는 것입니다. 
Iterator interface는 객체지향의 캡슐화를 잘 표현하고 있습니다. 내부의 일을 알려주지 않습니다. 외부의 행위는 변화지 않으며 격리시킬 수 있습니다.


다음은 Loop 문에 대한 ES6의 관점에서 이야기 해봅시다. 
Loop문을 구성하려면 바디를 서브루틴으로 만들어 주고, 실제로 go-to문 처럼 작동하게 됩니다.

이제부터는  ES6로 덕 타이핑을 구현하면 어떻게 언어스펙이 보여주는지 확인하려고 합니다.근본적으로 지현실현에 기반한 Iterator 루프에 대해 알아보고 언어서 실행만 책임지고 내부는 모두 개발자가 책임지는 부분을 알아보도록 하겠습니다.

언어에 따라서 Iterator,ITERABLE을 모두 직접 사용하게 해주는 문법들이 있습니다. 루프라는 함수를 구현한다고 할 때 우선 [Symbol.iterator]을 가지고 있는지 우선적으로 조사하게 됩니다. 함수로 가지고 있으면 ITERABLE객체라고 알게 되는것입니다. (ITERABLE은 Iterator객체를 가지고 있습니다.)
이 구분을 옵셔널로 해서 해당하지 않으면 기본값을 Iterator로 보겠다(next()호출가능)고 생각합니다. 그 후 쉴드패턴으로 IteratorObject가 아니라면 건너뛰게 만든 다음에야 실제 처리를 추가합니다. 실제 처리는 done() 가 true일 때 빠져나오도록 break를 둡니다.

다음은 이것을 내장해서 처리하는 문법을 보게 됩니다. 첫번째로 내장반복 처리기의 Array destructuning(배열해체)를 보게 됩니다. 이전 수업을 보면 배열에 대한 해체가 아니라 실제로는 ITERABLE을 해체하는 것이라고 이해 할 수 있습니다. 해체구문은 Iterator,ITERABLE을 다 받아줍니다.
(아래의 링크는 해체에 대한 대체에 대한 글입니다. 강의와 맞지 않는 것 처럼 생각 될 수 있으나 설명하시기 전 개요 부분에 강의 내용에 해당하는 부분이 충분히 설명되어 있습니다. ES6 환경이 아닐 때도 도움이 될 것 같습니다.)
http://www.bsidesoft.com/?p=2295
http://www.bsidesoft.com/?p=2298

구현해보니 컴파일러의 도움도 없이 언어스펙의 도움으로 이런 부분이 다 구현된다고 생각하니 알고 있는사람들만 기본 문법의 혜택을 받는 것인지 다시한번 생각하게 됩니다. 그러면 배열은 이런 부분이 왜 가능할까요? 배열에는 [Symbol.iterator] 메소드를 가지고 있기 때문입니다.
이제 루프는 스스로가 상태를 관리하고 있기 때문에 소비의 패턴을 다양하게 할 수 있습니다.

그다음에 펼치기(Spread) 연산자가 있습니다. 내부에서 소비하는 비슷한 부분입니다. 배열헤체는 루프의 통제권을 가지고 있다는 부분에서 기존과 다른길을 가게 되고 이러한 차이로 많은 일을 하게 될 수 있습니다. 그 다음에는 나머지 인자(Rest Parameter)가 있습니다. 헤체와는 다르게 함수 인자에 붙이면 나누에 져서 들어가게 됩니다. 여러개의 인자로 받아 들어오는것을 하나의 배열로 묶어서 내부에 전달하게 됩니다. 펼치기 연산자와 나머지인자 연산자의 차이점은 장소의 차이입니다. 함수 선언 시 사용되면 나머지 인자이고, 함수가 아닌곳에서 사용하는 것은 나머지 연산자라고 생각하시면 됩니다.
나머지 인자(Rest Parameter)로 만든 것을 펼치기(Spread)로 소비한다고(value값으로 함) 외워 두시면 됩니다. 예전의 argumunts 처럼 지역변수임에도 불구하고 전역변수나 자유변수로 인식되는 착각을 방지하게 됩니다. 또한 함수 내 this처럼 혼동하게 되는 부분도 방지 할 수 있습니다. (this는 class안에서만 쓰도록 하게 됩니다. 화살표함수에서도 사용 할 수 없는것처럼 ES6에서 추구하고 있습니다.) 나머지 인자(Rest Parameter)로 쓰면 apply()나 call()을 사용 할 필요가 없습니다. 두 개가 지원할 수 없었던 생성자를 전달 할 수 없던 문제도 해결 할 수 있습니다.

다음으로 새롭게 추가된 For of 구문의 추가를 확인할 수 있습니다. for in 구문처럼 사용하나 사용하면 뒤쪽에는 iterator구문이 올 수 있습니다. 그래서 done() 가 될 때까지 value를 받아올 수 있습니다. 루프횟수의 통제는 뒤의 iterator구문이 소비를 담당하게 됩니다.

next()를 호출할 때 함수를 호출한다면 지연을 시킬 수 있습니다. 루프에 해당하는 값을 미리 가지고 있지 않아도 됩니다. next()가 호출 될 때마다 값을 만들면 되기 때문입니다.예젠에는 루프의 요소의 대상이 항상 정해져 있었으나 지금은 요소를 계산하여 (next()에서 만들어서) 자유변수를 참조하게 만들어 this를 반환하며 this가 Iterator객체임과 동시에 Iterator resultObject가 되도록 하는 방법을 사용합니다. 이런게 바로 덕 타이핑의 능력을 이용한 객체 제어라고 할 수 있습니다.

이제는 GENEATOR을 Iterator GENEATOR로 보게되는 관점을 가져봅시다. GENEATOR는 Iterator처럼 메소드가 없지만 함수를 호출하면 결과가 Iterator가나옵니다. GENEATOR는 Iterator와 비슷해 보이지만, 호출한 결과물은 Iterator가 나옵니다. 따라서 for 에 GENEATOR는 줄 수 없습니다. 호출한 결과물을 for나 for of에 줄 수 없습니다.
http://www.bsidesoft.com/?p=2053
http://www.bsidesoft.com/?p=5494&

Iterator에서 구현되었을 때 여러 스펙의 조건들을 GENEATOR을 이용하여 짧은 코드로 구현 할 수 있습니다. arrow (=>) 함수를 사용 할 수 없이 function* 을 사용해야 합니다. 그리고 yield 가 value에 대항하는 구문으로 등장합니다. GENEATOR는 while 문을 쓴다 하더라도 제어문을 멈출 수 있습니다. 다음에 실행 되었을 때 다음 진입을 일반적인 루틴이 아닌 진입점을 여러번 진입 할 수 있고 포인트도 여러 군데에 있습니다. 이것을 코루틴(coroutine) 이라고 합니다. 마치 함수를 호출한 것처럼 제어문이 지연 실행을 일으키고 있습니다. 그리고 Iterator에서 자유변수나 내부의 프로퍼티를 썼던 부분을 GENEATOR을 이용하여 지역변수를 사용하여 할 수 있게 됩니다. 마지막에 실현하면 자동 true가 됩니다.

소비하는 방법은 간단합니다. GENEATOR을 호출하면 Iterator가 반환되어 호출하면 됩니다. (for of를 사용할 수 있습니다.)













