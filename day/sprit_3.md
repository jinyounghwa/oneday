코드 스피리츠 3회차 후기

이번 시간에는 기본적인 제어흐름에서의 반복구문에 대한 내용입니다.

일반적인 제어 흐름에 대한 이야기이며 다음에는 코루틴을 합니다.  
자바스크립트에서 이제부터는 인터페이스에 대한 이야기를 해봅시다. 인터페이스는 고유명사이니다. (ES6이후)
1. 인터페이스는 사양에 맞는 값과 연결된 속성키의 세트입니다.
2. 어던 Object라도 인터페이스의 정의를 충족 시키실 수 있습니다.
3. 하나의 Object는 여러개의 인터페이스를 충족 시킬 수 있습니다.

마치 JAVA에서 클래스가 여러 오브젝트를 생성하는 것과 비슷합니다. 
예로  TEST라는 인터페이스를 생각해봅시다. 이것은
1. test라는 키를 가지고
2. 값으로 문자열인자를 1개 받아 불린 결과를 반환하는 함수가 옵니다.
test인터페이스를 제대로 구분하려면 키와 함수를 가지고 있습니다. 

인터페이스 개념은 duck typing에서 왔습니다. 클래스는 단지 구현만 하고 있을 뿐이지 해당 메소드를 가지고 있는게 보장되지는 않습니다. 인스턴스 일 뿐이라 컴파일 에러가 나지 않습니다. 객체가 느슨하게 인터페이스를 구현했다면 그게 뭐든 상관하지 않겠다. (조건이 맞다면 해당 인터페이스의 사용가능할 객체로 인식하겠다 라는 말이죠.. 타입체크가 안 되기 때문에 사용합니다.)
덕타이핑이 어려운 이유는 이것을 우리 머리속에서 구현하기 어렵기 때문입니다. 실제 사용하려면 상당히 어렵습니다. 

그러면 인터페이스가 무엇인지 알았으니 스펙에서 미리 규정하고 있는 인터페이스를 알아보겠습니다.
이중에 반복문과 관련된 것이 두가지 있습니다. 그중 하나는 ITERATOR INTERFACE입니다. 이것은 무엇을 요구하냐면 다음과 같습니다.
1. next라는 키를 가지고 
2. 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 프로토콜입니다.
3. IteratorResultObject(이것도 인터페이스 입니다.) 는 value와 done라는 키를 가지고 있습니다.
4. 이중 done은 계속 반환할 수 있을지 없을지에 따라 불린값을 반환합니다.

인터페이스가 인터페이스를 부르는 경우가 많으니 예제들을 검색해서 찾아보도록 합시다. 
done는 next를 부를지 말지 판단할 때 사용하고 value는 그때그때 값을 받아오기 위함이라고 일단 머리에 넣어봅시다.

그럼 이것을 어떨 때 사용할 수 있을까요? 의도적으로 내부에 변수를 숨겨 반복을 구현하여 데이터 길이만큼 순환할 경우 등으로 확인 할 수 있습니다.

이제는 ITERABLE INTERFACE(위의것과 헷갈리지만 구분해서 반드시 외워야 합니다.)
1. Symbol.iterator라는 키를 가지고
2. 값으로 인자를 받지 않고 IteratorObject를 반환해야 합니다.

Symbol은 ES6에서 생긴 primitive type(메모리에 복사가 일어나는 형식의 타입:참조가 아니라 복사가 일어나는 모든 심볼은 유니크 값입니다.)
사용할 때 대괄호 [Symbol.iterator] 라고 씁니다. (new를 사용할 수 없습니다.) 심볼은 원래 내장하고 있는 심볼(well-known symbols)가 있습니다.
영문이지만 아래 링크에 소개가 있으니 시간나실 때 읽어봐 주세요(저도 읽어보겠습니다.)
http://2ality.com/2015/09/well-known-symbols-es6.html
또한 강의에서 말씀하신 심볼이 어떤 문자열 인터페이스로 대체되는지 대한 표등에 대한 링크는 아래의 글을 한번 읽어보시고 그 글의 링크를 클릭하셔서 확인해 보시면 됩니다.
http://www.bsidesoft.com/2306

well-known symbols는 문자로 대체가 가능합니다. 키가 변수의 명명규칙에 일치하지 않아도 대괄호 규칙을 하는것을 권합니다. 비슷한 영어발음이어서 헷갈리는것 중에 하나가 ITERABLE의 키가 iterator라는 부분입니다. ES6에서는 키가 오고 괄호가 오면 [Symbol.iterator] () key:function이 온 것과 같은 의미를 가집니다.(메소드 문법이라 합니다.)


ITERABLE의 의미는 iterator로 한번 반복시키고 나면, 수명이 다해서 없어지는데 원본을 두고 계속해서 반복 하는 방법을 사용하기 위함입니다.(class를 사용합니다.) 이것이 바로 ITERABLE 인터페이스 입니다.

이제 인터페이스에 대한 개념을 배웠으니 이제는 LOOP에 대하여 배워봅시다.
ES6는 스팩과 엔진으 모두 새롭게 구성되어 있기 때문에 기존의 방식은 전혀 통용되지 않습니다. 이 점을 유의하여 새로운 마음으로 배워보도록 하겠습니다.

ES6는 어떤 방식으로 플로우를 컨트롤 할까요? while문의 구조로 한번 살펴보도록 하겠습니다. 이것을 Iterator interface로 보면 구조는 거의 비슷하다는 것을 느낄 수 있습니다. 다만 판단을 내부에 맡기고 처리할 것이 값이라면 또한 출력이 가능합니다. 구조를 거의 흉내 낸다고 할 수 있습니다. JAVA도 마찬가지 입니다. 

물론 차이점이 있습니다. 값과 문의 차이입니다. 문으로 루프를 돌리면 재현이 불가능하고 원한할 때 실행하기도 어렵습니다. 휘발성이죠.. 값으로 바꾸지 않으면.. 컴퓨터 성능에 대한 차이와 같이 문은 그런 동작구조이지만 Iterator와 같이 값으로 실행하면 우리가 제어할 수 있습니다. (지연처리와 흐름제어라고 합니다. 해당포스팅은 아래 링크 입니다.)
http://www.bsidesoft.com/?p=2862

지연처리라는 말은 실행 도중에 실행을 점프시키고 처리하는 것을 말합니다. 또한 연산자를 지연처리도 있고 호출 지연도 있습니다. 함수를 실행했을 때 결과는 값이기에 원하는 때에 실행할 수 있는 처리가 가능한 것입니다.

다시 돌아와서 문(while의 경우) 휘발성이며 통제가 되지 않습니다만, 그에 비애 Iterator interface는 next()호출 할 때까지 다음번 루프가 실행되지 않습니다. 호출을 원할 때 할 수 있습니다. 값으로 바꾸고 함수의 호출 지연을 사용하기 때문입니다. 대신에 귀찮은게 있다면 문은 실행을 엔진이 하지만
Iterator interface(공급기)는 실행기를 반드시 만들어야 합니다.
정리하자면 다음과 같습니다.
1. 반복자체는 하지 않지만
2. 외부에서 반복을 하려고 할 때
3. 반복에 필요한 존건과 실행을 
4. 미리 준비해 둔 객체에서 
-반복행위(진짜로 next를 호출)와 반복(상태준비)을 위한 준비를 분리합니다.-
1. 미리 반복에 대한 준비를 해두고(이것조차 객체에 위임합니다.)
2. 필요할 대 필요한 만큼 반복
3. 반복을 재현할 수 있음(문과는 달리 통제도 가능함)

기본적으로 서술적 표현이었던 문을 대상화 시키서 쉬워지게 만들어 한다고 생각하여 쉽게 사용할 수 있겠지.. 라고 대상화 하여 만든것입니다... 
미리준비해 둔 객체라고 합니다. 객체의 중요한 특성은 캡슐화 입니다. 결과를 구현해 내는 과정에 대한 부분이 노출되지 않는 것입니다. 
Iterator interface는 객체지향의 캡슐화를 잘 표현하고 있습니다. 내부의 일을 알려주지 않습니다. 외부의 행위는 변화지 않으며 격리시킬 수 있습니다.



